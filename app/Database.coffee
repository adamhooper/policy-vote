readline = require('readline')

PolicyIds = require('../lib/Policies').byId

# Holds all the votes.
#
# The database is write-only, which means we only ever *append* to our CSV
# file, `votes.csv`. We keep things super-simple by ignoring the write() return
# value: a hard failure will kill the app, but a full buffer will simply force
# Node to use up more memory (which is fine, as long as traffic subsides). So
# most methods return synchronously.
#
# It's no big deal if we lose a vote or two. (That's why we return before a
# disk write succeeds.)
#
# We anticipate an upper bound of 5M users, 20 votes per user: 100M votes at
# ~100b/vote -> 10GB in votes.csv.
#
# Oh yeah. What's a vote? A CSV row that looks like this:
#
# * betterPolicyId: A Policy ID
# * worsePolicyId: A Policy ID
# * languageCode: 'en' or 'fr'
# * provinceCode: 'bc' to 'nl', or '' if no province was chosen
# * userId: A GUID String (generated by the server)
# * ip: A String
module.exports = class Database
  # Options:
  #
  # * csvOutputStream: where to write when a new Vote is created.
  constructor: (options={}) ->
    throw 'Must set options.csvOutputStream' if !options.csvOutputStream?.write

    @_nVotes = 0
    @_nVotesByPolicyId = {}
    @_users = {}

    @csvOutputStream = options.csvOutputStream

  # Adds the vote, but doesn't write to CSV.
  #
  # Returns true if the vote is valid. (We ban invalid policy IDs, because that
  # could lead to DOS.)
  _addVote: (betterPolicyId, worsePolicyId) ->
    # Don't write invalid policy IDs: that would let one user ruin the
    # experience for everybody.
    #
    # Normally we'd be checking this in the controller. But on restart, a
    # Policy that once existed may have since been deleted. That would leave
    # rows in the CSV that we should ignore.
    if betterPolicyId of PolicyIds && worsePolicyId of PolicyIds
      @_nVotes++
      @_nVotesByPolicyId[betterPolicyId] ?= { aye: 0, nay: 0 }
      @_nVotesByPolicyId[betterPolicyId].aye++
      @_nVotesByPolicyId[worsePolicyId] ?= { aye: 0, nay: 0 }
      @_nVotesByPolicyId[worsePolicyId].nay++
      true
    else
      false

  # Adds a Vote to the database for the given User.
  addVote: (vote) ->
    if !vote.betterPolicyId? || !vote.worsePolicyId? || !vote.languageCode || !vote.provinceCode? || !vote.userId || !vote.ip
      throw new Error("Assertion error: invalid Vote #{JSON.stringify(vote)}")

    if @_addVote(vote.betterPolicyId, vote.worsePolicyId)
      @csvOutputStream.write([
        vote.betterPolicyId,
        vote.worsePolicyId,
        vote.languageCode,
        vote.provinceCode,
        vote.userId,
        vote.ip
      ].join(',') + '\n', 'utf-8', (err) -> console.warn(err) if err)
    else
      console.log("Skipped vote with invalid policy(ies): #{JSON.stringify(vote)}")

  # Returns the total number of votes.
  getNVotes: -> @_nVotes

  # Returns an Object mapping policy ID (stringified) to a Number of votes.
  #
  # The Number returned is the number of *aye* votes minus the number of *nay*
  # votes.
  getNVotesByPolicyId: -> @_nVotesByPolicyId

  # Populates the database from previously-written CSV files.
  #
  # This method is asynchronous. You probably mean to run it on app startup; in
  # that case, don't respond to users until the loading is finished.
  load: (csv, done) ->
    throw new Error('The database is not empty. DO NOT call load() now.') if @_nVotes > 0

    lastPartialLine = ''

    csv
      .on 'data', (chunk) =>
        lines = chunk.split('\n')
        lines[0] = lastPartialLine + lines[0]
        if chunk[chunk.length - 1] == '\n'
          lastPartialLine = ''
        else
          lastPartialLine = lines.pop()

        for line in lines
          [ betterPolicyId, worsePolicyId ] = line.split(',', 2)
          @_addVote(betterPolicyId, worsePolicyId)
      .on 'end', =>
        [ betterPolicyId, worsePolicyId ] = lastPartialLine.split(',', 2)
        @_addVote(betterPolicyId, worsePolicyId)

        done()
